{"ast":null,"code":"var _jsxFileName = \"/Users/emrahcercioglu/>DEMO/missile-tracker/frontend/src/contexts/SocketContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useEffect, useState, useCallback } from 'react';\nimport { io } from 'socket.io-client';\nimport toast from 'react-hot-toast';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SocketContext = /*#__PURE__*/createContext();\nexport const useSocket = () => {\n  _s();\n  const context = useContext(SocketContext);\n  if (!context) {\n    throw new Error('useSocket must be used within a SocketProvider');\n  }\n  return context;\n};\n_s(useSocket, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport const SocketProvider = ({\n  children\n}) => {\n  _s2();\n  const [socket, setSocket] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [connectionStats, setConnectionStats] = useState({\n    totalConnections: 0\n  });\n  const [lastPing, setLastPing] = useState(null);\n  const connect = useCallback(() => {\n    const socketUrl = process.env.REACT_APP_WS_URL || 'ws://localhost:5000';\n    const newSocket = io(socketUrl, {\n      transports: ['websocket', 'polling'],\n      timeout: 20000,\n      reconnection: true,\n      reconnectionDelay: 1000,\n      reconnectionAttempts: 5,\n      maxReconnectionAttempts: 10\n    });\n\n    // Connection events\n    newSocket.on('connect', () => {\n      console.log('游댋 Connected to WebSocket server');\n      setIsConnected(true);\n      toast.success('Connected to real-time updates');\n\n      // Subscribe to channels\n      newSocket.emit('subscribe', {\n        channels: ['missiles', 'alerts', 'system']\n      });\n    });\n    newSocket.on('disconnect', reason => {\n      console.log('游댋 Disconnected from WebSocket server:', reason);\n      setIsConnected(false);\n      if (reason === 'io server disconnect') {\n        // Server disconnected, manual reconnection needed\n        toast.error('Server disconnected. Attempting to reconnect...');\n      } else {\n        toast.error('Connection lost. Reconnecting...');\n      }\n    });\n    newSocket.on('connect_error', error => {\n      console.error('游댋 Connection error:', error);\n      toast.error('Failed to connect to server');\n    });\n    newSocket.on('reconnect', attemptNumber => {\n      console.log(`游댋 Reconnected after ${attemptNumber} attempts`);\n      toast.success('Reconnected to server');\n    });\n    newSocket.on('reconnect_error', error => {\n      console.error('游댋 Reconnection error:', error);\n    });\n    newSocket.on('reconnect_failed', () => {\n      console.error('游댋 Failed to reconnect');\n      toast.error('Failed to reconnect. Please refresh the page.');\n    });\n\n    // Subscription confirmations\n    newSocket.on('subscription_confirmed', data => {\n      console.log('游니 Subscribed to channels:', data.channels);\n    });\n    newSocket.on('unsubscription_confirmed', data => {\n      console.log('游니 Unsubscribed from channels:', data.channels);\n    });\n\n    // Connection stats\n    newSocket.on('connection_stats', stats => {\n      setConnectionStats(stats);\n    });\n\n    // Ping/Pong for connection monitoring\n    newSocket.on('pong', data => {\n      setLastPing(Date.now() - data.timestamp);\n    });\n    setSocket(newSocket);\n    return newSocket;\n  }, []);\n  const disconnect = useCallback(() => {\n    if (socket) {\n      socket.disconnect();\n      setSocket(null);\n      setIsConnected(false);\n    }\n  }, [socket]);\n  const subscribe = useCallback(channels => {\n    if (socket && isConnected) {\n      socket.emit('subscribe', {\n        channels\n      });\n    }\n  }, [socket, isConnected]);\n  const unsubscribe = useCallback(channels => {\n    if (socket && isConnected) {\n      socket.emit('unsubscribe', {\n        channels\n      });\n    }\n  }, [socket, isConnected]);\n  const requestHistoricalData = useCallback((timeRange, filters) => {\n    if (socket && isConnected) {\n      socket.emit('request_historical_data', {\n        timeRange,\n        filters\n      });\n    }\n  }, [socket, isConnected]);\n  const ping = useCallback(() => {\n    if (socket && isConnected) {\n      socket.emit('ping');\n    }\n  }, [socket, isConnected]);\n\n  // Initialize connection on mount\n  useEffect(() => {\n    const newSocket = connect();\n    return () => {\n      if (newSocket) {\n        newSocket.disconnect();\n      }\n    };\n  }, [connect]);\n\n  // Periodic ping for connection monitoring\n  useEffect(() => {\n    if (isConnected) {\n      const pingInterval = setInterval(ping, 30000); // Ping every 30 seconds\n      return () => clearInterval(pingInterval);\n    }\n  }, [isConnected, ping]);\n  const value = {\n    socket,\n    isConnected,\n    connectionStats,\n    lastPing,\n    connect,\n    disconnect,\n    subscribe,\n    unsubscribe,\n    requestHistoricalData,\n    ping\n  };\n  return /*#__PURE__*/_jsxDEV(SocketContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 165,\n    columnNumber: 5\n  }, this);\n};\n_s2(SocketProvider, \"Nr9gvSzicTy3Vk+2CHt3MyBf/7I=\");\n_c = SocketProvider;\nvar _c;\n$RefreshReg$(_c, \"SocketProvider\");","map":{"version":3,"names":["React","createContext","useContext","useEffect","useState","useCallback","io","toast","jsxDEV","_jsxDEV","SocketContext","useSocket","_s","context","Error","SocketProvider","children","_s2","socket","setSocket","isConnected","setIsConnected","connectionStats","setConnectionStats","totalConnections","lastPing","setLastPing","connect","socketUrl","process","env","REACT_APP_WS_URL","newSocket","transports","timeout","reconnection","reconnectionDelay","reconnectionAttempts","maxReconnectionAttempts","on","console","log","success","emit","channels","reason","error","attemptNumber","data","stats","Date","now","timestamp","disconnect","subscribe","unsubscribe","requestHistoricalData","timeRange","filters","ping","pingInterval","setInterval","clearInterval","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/emrahcercioglu/>DEMO/missile-tracker/frontend/src/contexts/SocketContext.js"],"sourcesContent":["import React, { createContext, useContext, useEffect, useState, useCallback } from 'react';\nimport { io } from 'socket.io-client';\nimport toast from 'react-hot-toast';\n\nconst SocketContext = createContext();\n\nexport const useSocket = () => {\n  const context = useContext(SocketContext);\n  if (!context) {\n    throw new Error('useSocket must be used within a SocketProvider');\n  }\n  return context;\n};\n\nexport const SocketProvider = ({ children }) => {\n  const [socket, setSocket] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [connectionStats, setConnectionStats] = useState({ totalConnections: 0 });\n  const [lastPing, setLastPing] = useState(null);\n\n  const connect = useCallback(() => {\n    const socketUrl = process.env.REACT_APP_WS_URL || 'ws://localhost:5000';\n    \n    const newSocket = io(socketUrl, {\n      transports: ['websocket', 'polling'],\n      timeout: 20000,\n      reconnection: true,\n      reconnectionDelay: 1000,\n      reconnectionAttempts: 5,\n      maxReconnectionAttempts: 10\n    });\n\n    // Connection events\n    newSocket.on('connect', () => {\n      console.log('游댋 Connected to WebSocket server');\n      setIsConnected(true);\n      toast.success('Connected to real-time updates');\n      \n      // Subscribe to channels\n      newSocket.emit('subscribe', { \n        channels: ['missiles', 'alerts', 'system'] \n      });\n    });\n\n    newSocket.on('disconnect', (reason) => {\n      console.log('游댋 Disconnected from WebSocket server:', reason);\n      setIsConnected(false);\n      \n      if (reason === 'io server disconnect') {\n        // Server disconnected, manual reconnection needed\n        toast.error('Server disconnected. Attempting to reconnect...');\n      } else {\n        toast.error('Connection lost. Reconnecting...');\n      }\n    });\n\n    newSocket.on('connect_error', (error) => {\n      console.error('游댋 Connection error:', error);\n      toast.error('Failed to connect to server');\n    });\n\n    newSocket.on('reconnect', (attemptNumber) => {\n      console.log(`游댋 Reconnected after ${attemptNumber} attempts`);\n      toast.success('Reconnected to server');\n    });\n\n    newSocket.on('reconnect_error', (error) => {\n      console.error('游댋 Reconnection error:', error);\n    });\n\n    newSocket.on('reconnect_failed', () => {\n      console.error('游댋 Failed to reconnect');\n      toast.error('Failed to reconnect. Please refresh the page.');\n    });\n\n    // Subscription confirmations\n    newSocket.on('subscription_confirmed', (data) => {\n      console.log('游니 Subscribed to channels:', data.channels);\n    });\n\n    newSocket.on('unsubscription_confirmed', (data) => {\n      console.log('游니 Unsubscribed from channels:', data.channels);\n    });\n\n    // Connection stats\n    newSocket.on('connection_stats', (stats) => {\n      setConnectionStats(stats);\n    });\n\n    // Ping/Pong for connection monitoring\n    newSocket.on('pong', (data) => {\n      setLastPing(Date.now() - data.timestamp);\n    });\n\n    setSocket(newSocket);\n\n    return newSocket;\n  }, []);\n\n  const disconnect = useCallback(() => {\n    if (socket) {\n      socket.disconnect();\n      setSocket(null);\n      setIsConnected(false);\n    }\n  }, [socket]);\n\n  const subscribe = useCallback((channels) => {\n    if (socket && isConnected) {\n      socket.emit('subscribe', { channels });\n    }\n  }, [socket, isConnected]);\n\n  const unsubscribe = useCallback((channels) => {\n    if (socket && isConnected) {\n      socket.emit('unsubscribe', { channels });\n    }\n  }, [socket, isConnected]);\n\n  const requestHistoricalData = useCallback((timeRange, filters) => {\n    if (socket && isConnected) {\n      socket.emit('request_historical_data', { timeRange, filters });\n    }\n  }, [socket, isConnected]);\n\n  const ping = useCallback(() => {\n    if (socket && isConnected) {\n      socket.emit('ping');\n    }\n  }, [socket, isConnected]);\n\n  // Initialize connection on mount\n  useEffect(() => {\n    const newSocket = connect();\n    \n    return () => {\n      if (newSocket) {\n        newSocket.disconnect();\n      }\n    };\n  }, [connect]);\n\n  // Periodic ping for connection monitoring\n  useEffect(() => {\n    if (isConnected) {\n      const pingInterval = setInterval(ping, 30000); // Ping every 30 seconds\n      return () => clearInterval(pingInterval);\n    }\n  }, [isConnected, ping]);\n\n  const value = {\n    socket,\n    isConnected,\n    connectionStats,\n    lastPing,\n    connect,\n    disconnect,\n    subscribe,\n    unsubscribe,\n    requestHistoricalData,\n    ping\n  };\n\n  return (\n    <SocketContext.Provider value={value}>\n      {children}\n    </SocketContext.Provider>\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}